#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
End-to-end document image pipeline:

1) Azure Document Intelligence (prebuilt-layout, FIGURES) to extract figures as PNGs.
2) Azure Vision Image Analysis 4.0 to tag/caption each figure.
3) Auto-map figures to placeholders (or use a provided figure_map.json).
4) Replace [[IMG:<tag>]] placeholders across body, tables, headers/footers in a DOCX template.
5) Optional hi-DPI recrop from original PDF for better tagging.

Usage:
  python doc_image_pipeline.py \
     --doc input.pdf \
     --template template.docx \
     --out output.docx \
     [--map figure_map.json] \
     [--auto-map] \
     [--max-width-in 6.0] \
     [--use-hidpi-recrop]

Outputs:
  - extracted_images/*.png
  - image_tags.json
  - figure_map.autogenerated.json (if --auto-map)
  - output.docx
"""

import os
import re
import json
import argparse
from pathlib import Path
from typing import List, Dict, Any, Iterable, Optional

from PIL import Image

from azure.core.credentials import AzureKeyCredential
from azure.ai.documentintelligence import DocumentIntelligenceClient
from azure.ai.documentintelligence.models import AnalyzeOutputOption
from azure.ai.vision.imageanalysis import ImageAnalysisClient
from azure.ai.vision.imageanalysis.models import VisualFeatures

# Optional PyMuPDF for hi-DPI recrops
try:
    import fitz  # PyMuPDF
    PYMUPDF_AVAILABLE = True
except Exception:
    PYMUPDF_AVAILABLE = False

# ---------------------- Helpers: Vision ----------------------

STOPWORDS = {
    "a","an","the","in","of","on","with","and","to","for","at","from","by","is","are","this","that","it","as","be","or"
}

def keywords_from_caption(text: Optional[str]) -> List[str]:
    if not text:
        return []
    words = [w.strip(",.()[]{}:;!?'\"").lower() for w in text.split()]
    return [w for w in words if w and w not in STOPWORDS and len(w) > 2]

def _values_list(container) -> List[Any]:
    """Return a safe list from .values which might be a property OR a method."""
    if container is None:
        return []
    vals = getattr(container, "values", None)
    if callable(vals):  # handle values() method
        vals = vals()
    if vals is None:
        return []
    if isinstance(vals, (list, tuple)):
        return list(vals)
    try:
        return list(vals)
    except TypeError:
        return []

def extract_caption(result) -> Optional[str]:
    cap = getattr(result, "caption", None)
    return getattr(cap, "text", None) if cap else None

# ---------------------- Helpers: DOCX placement ----------------------

PLACEHOLDER_REGEX = re.compile(r"\[\[IMG:([A-Za-z0-9_.\-]+)\]\]")

def iter_paragraphs(document) -> Iterable:
    # body
    for p in document.paragraphs:
        yield p
    # tables in body
    for t in document.tables:
        for row in t.rows:
            for cell in row.cells:
                for p in cell.paragraphs:
                    yield p
    # headers/footers
    for section in document.sections:
        # headers
        for hdr in [section.header, getattr(section, "first_page_header", None), getattr(section, "even_page_header", None)]:
            if hdr:
                for p in hdr.paragraphs:
                    yield p
                for t in hdr.tables:
                    for row in t.rows:
                        for cell in row.cells:
                            for p in cell.paragraphs:
                                yield p
        # footers
        for ftr in [section.footer, getattr(section, "first_page_footer", None), getattr(section, "even_page_footer", None)]:
            if ftr:
                for p in ftr.paragraphs:
                    yield p
                for t in ftr.tables:
                    for row in t.rows:
                        for cell in row.cells:
                            for p in cell.paragraphs:
                                yield p

def replace_placeholders_in_paragraph(paragraph, placeholder_map, fig_index, max_width_in=6.0) -> int:
    """Replace all [[IMG:tag]] occurrences in a paragraph (works even if split across runs)."""
    from docx.shared import Inches
    full_text = "".join(run.text or "" for run in paragraph.runs)
    if "[[IMG:" not in full_text:
        return 0

    # Clear runs
    for r in list(paragraph.runs):
        r.text = ""

    inserted, pos = 0, 0
    for m in PLACEHOLDER_REGEX.finditer(full_text):
        # text before placeholder
        before = full_text[pos:m.start()]
        if before:
            paragraph.add_run(before)

        tag = m.group(1)
        fig_id = placeholder_map.get(tag)
        img_path = fig_index.get(fig_id) if fig_id else None

        if img_path and Path(img_path).exists():
            with Image.open(img_path) as im:
                width_px, _ = im.size
                width_in = min(max_width_in, max(1.0, width_px / 96.0))  # assume ~96 DPI
            run_img = paragraph.add_run()
            run_img.add_picture(img_path, width=Inches(width_in))
            inserted += 1
        else:
            # keep literal placeholder if not mapped / image missing
            paragraph.add_run(full_text[m.start():m.end()])

        pos = m.end()

    # trailing text
    tail = full_text[pos:]
    if tail:
        paragraph.add_run(tail)

    return inserted

# ---------------------- Optional hi-DPI re-crop ----------------------

def recrop_from_pdf(pdf_path: Path, page_one_based: int, rect_xyxy: List[float], dpi: int = 240) -> Optional[bytes]:
    """Re-crop a higher-resolution image from the original PDF page region."""
    if not PYMUPDF_AVAILABLE:
        return None
    doc = fitz.open(pdf_path.as_posix())
    page = doc[page_one_based - 1]
    rect = fitz.Rect(*rect_xyxy)
    mat = fitz.Matrix(dpi/72.0, dpi/72.0)
    pix = page.get_pixmap(matrix=mat, clip=rect, alpha=False)
    return pix.tobytes("png")

# ---------------------- Main pipeline ----------------------

def main():
    parser = argparse.ArgumentParser(description="Extract, tag, and place images into a DOCX.")
    parser.add_argument("--doc", default="input.pdf", help="Source document (PDF recommended).")
    parser.add_argument("--template", default="template.docx", help="DOCX with [[IMG:tag]] placeholders.")
    parser.add_argument("--out", default="output.docx", help="Output DOCX filename.")
    parser.add_argument("--map", dest="map_path", default="figure_map.json",
                        help="JSON mapping {placeholderTag: figureId}. If missing and --auto-map is set, builds automatically.")
    parser.add_argument("--auto-map", action="store_true", help="Auto-map placeholders to figures by tag scoring (fallback to size).")
    parser.add_argument("--max-width-in", type=float, default=6.0, help="Max image width (inches).")
    parser.add_argument("--use-hidpi-recrop", action="store_true", help="Use hi-DPI recrop for Vision tagging (PyMuPDF).")
    args = parser.parse_args()

    DOC_PATH = Path(args.doc)
    TEMPLATE_DOCX = Path(args.template)
    OUTPUT_DOCX = Path(args.out)
    MAP_JSON = Path(args.map_path)

    IMG_DIR = Path("extracted_images")
    IMG_DIR.mkdir(exist_ok=True)

    # Clients
    di = DocumentIntelligenceClient(
        endpoint=os.environ["DOCUMENTINTELLIGENCE_ENDPOINT"],
        credential=AzureKeyCredential(os.environ["DOCUMENTINTELLIGENCE_API_KEY"])
    )
    vision = ImageAnalysisClient(
        endpoint=os.environ["VISION_ENDPOINT"],
        credential=AzureKeyCredential(os.environ["VISION_KEY"])
    )

    # 1) Analyze + extract figures
    with open(DOC_PATH, "rb") as f:
        poller = di.begin_analyze_document("prebuilt-layout", body=f, output=[AnalyzeOutputOption.FIGURES])
    result = poller.result()
    operation_id = poller.details["operation_id"]

    fig_index: Dict[str, str] = {}  # figureId -> local path
    tag_dict: Dict[str, Dict[str, Any]] = {}  # figureId -> {"tags":[], "caption": str}

    if getattr(result, "figures", None):
        for fig in result.figures:
            if not fig.id:
                continue

            # Download DI crop
            stream = di.get_analyze_result_figure(model_id=result.model_id, result_id=operation_id, figure_id=fig.id)
            out_path = IMG_DIR / f"{fig.id}.png"
            with open(out_path, "wb") as w:
                for chunk in stream:
                    w.write(chunk)
            fig_index[fig.id] = out_path.as_posix()

            # Optional hi-DPI recrop for Vision
            img_bytes = None
            if args.use_hidpi_recrop and PYMUPDF_AVAILABLE and getattr(fig, "bounding_regions", None):
                try:
                    br = fig.bounding_regions[0]
                    poly = getattr(br, "polygon", None)
                    if poly and len(poly) >= 4:
                        xs = [p.x for p in poly]
                        ys = [p.y for p in poly]
                        rect = [min(xs), min(ys), max(xs), max(ys)]
                        img_bytes = recrop_from_pdf(DOC_PATH, br.page_number, rect, dpi=240)
                except Exception:
                    img_bytes = None

            # 2) Tag with Vision
            try:
                if img_bytes is None:
                    with open(out_path, "rb") as fimg:
                        img_bytes = fimg.read()

                ia = vision.analyze(
                    image_data=img_bytes,
                    visual_features=[VisualFeatures.TAGS, VisualFeatures.CAPTION, VisualFeatures.DENSE_CAPTIONS]
                )

                tag_vals = _values_list(getattr(ia, "tags", None))
                tags = [getattr(v, "name", None) for v in tag_vals
                        if getattr(v, "confidence", 0) >= 0.55 and getattr(v, "name", None)]

                caption = extract_caption(ia)

                if not tags:
                    dense_vals = _values_list(getattr(ia, "dense_captions", None))
                    if dense_vals:
                        seen = set()
                        tags = [dc.text for dc in dense_vals
                                if getattr(dc, "text", None) and not (dc.text in seen or seen.add(dc.text))]
                if not tags and caption:
                    tags = keywords_from_caption(caption)

                tag_dict[fig.id] = {"tags": tags, "caption": caption}

            except Exception as ex:
                tag_dict[fig.id] = {"tags": [], "caption": None, "error": str(ex)}
    else:
        print("No figures found.")

    # Sidecar tags file
    with open("image_tags.json", "w", encoding="utf-8") as jf:
        json.dump(tag_dict, jf, ensure_ascii=False, indent=2)

    # 3) Build placeholder map
    placeholder_map: Dict[str, str] = {}
    if MAP_JSON.exists():
        with open(MAP_JSON, "r", encoding="utf-8") as mf:
            placeholder_map = json.load(mf)
    elif args.auto_map:
        # Prefs for common tags per placeholder (customize as needed)
        placeholder_prefs = {
            "cover":      ["cover", "hero", "people", "person", "portrait", "man", "woman"],
            "chart-1":    ["chart", "graph", "plot", "bar", "line", "pie"],
            "diagram-42": ["diagram", "flowchart", "schematic", "network", "architecture"]
        }

        # Read image_tags.json
        image_tags = tag_dict

        def score(tags, wants):
            tags_l = {t.lower() for t in (tags or [])}
            return sum(1 for w in wants if w in tags_l)

        # image areas (for tie-break / fallback)
        sizes = {}
        for fid, p in fig_index.items():
            try:
                with Image.open(p) as im:
                    sizes[fid] = im.size[0] * im.size[1]
            except Exception:
                sizes[fid] = 0

        # discover placeholders in doc order
        from docx import Document as _D
        dtmp = _D(TEMPLATE_DOCX.as_posix())
        placeholders_order = []
        for p in iter_paragraphs(dtmp):
            text = "".join(r.text or "" for r in p.runs)
            for m in PLACEHOLDER_REGEX.finditer(text):
                placeholders_order.append(m.group(1))

        used = set()
        for ph in placeholders_order:
            wants = placeholder_prefs.get(ph, [])
            ranked = sorted(
                image_tags.items(),
                key=lambda kv: (score(kv[1].get("tags"), wants), sizes.get(kv[0], 0)),
                reverse=True
            )
            chosen = None
            for fid, meta in ranked:
                if fid in used:
                    continue
                if score(meta.get("tags"), wants) > 0:
                    chosen = fid
                    break
            if not chosen:
                for fid, _ in ranked:
                    if fid not in used:
                        chosen = fid
                        break
            if chosen:
                placeholder_map[ph] = chosen
                used.add(chosen)

        with open("figure_map.autogenerated.json", "w", encoding="utf-8") as f:
            json.dump(placeholder_map, f, ensure_ascii=False, indent=2)
        print("Auto-mapped placeholders -> figures written to figure_map.autogenerated.json")

    # 4) Apply mapping to DOCX
    from docx import Document as DocxDocument
    doc = DocxDocument(TEMPLATE_DOCX.as_posix())
    replaced = 0
    missing = []

    for para in iter_paragraphs(doc):
        # Count number of placeholders before replacing (to detect intent)
        text = "".join(r.text or "" for r in para.runs)
        if "[[IMG:" not in text:
            continue
        # Replace all in this paragraph
        before_count = len(list(PLACEHOLDER_REGEX.finditer(text)))
        replaced_here = replace_placeholders_in_paragraph(
            para, placeholder_map=placeholder_map, fig_index=fig_index, max_width_in=args.max_width_in
        )
        replaced += replaced_here
        # Record missing ones
        for m in PLACEHOLDER_REGEX.finditer(text):
            tag = m.group(1)
            if tag not in placeholder_map or placeholder_map[tag] not in fig_index:
                missing.append(tag)

    doc.save(OUTPUT_DOCX.as_posix())

    # Summary
    print(json.dumps({
        "figures_extracted": len(fig_index),
        "tags_written": len(tag_dict),
        "placeholders_replaced": replaced,
        "placeholders_without_mapping_or_image": sorted(set(missing)),
        "output_docx": OUTPUT_DOCX.as_posix(),
        "image_tags_json": "image_tags.json",
        "auto_map_used": (not MAP_JSON.exists()) and args.auto_map
    }, indent=2))


if __name__ == "__main__":
    main()

